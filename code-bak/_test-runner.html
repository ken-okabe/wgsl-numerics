<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>WGSL Numerics - E2E Test Runner</title>
</head>
<body>
    <h1>WGSL Numerics - E2E Test Runner</h1>
    <script type="module">
        console.log("[Browser] Script started. Connecting to WebSocket...");
        const ws = new WebSocket(`ws://${location.host}`);

        ws.onopen = () => console.log("[Browser] WebSocket connection opened.");
        ws.onclose = () => console.log("[Browser] WebSocket connection closed.");
        ws.onerror = (err) => console.error("[Browser] WebSocket error:", err);

        ws.onmessage = async (event) => {
            const testData = JSON.parse(event.data);

            if (testData.command === 'close') {
                console.log("[Browser] Received close command. Closing WebSocket.");
                ws.close();
                return;
            }

            try {
                // ▼▼▼ 修正箇所: 文字列から特殊値を復元 ▼▼▼
                const deserializedInput = testData.input.map((v) => {
                    if (v === 'NaN') return NaN;
                    if (v === 'Infinity') return Infinity;
                    if (v === '-Infinity') return -Infinity;
                    if (v === '-0') return -0;
                    return v;
                });
                testData.input = deserializedInput;
                // ▲▲▲ 修正箇所 ▲▲▲

                const result = await runGpuTest(testData);
                const resultString = Array.from(result).join(',');
                ws.send(JSON.stringify({ result: resultString }));
            } catch (e) {
                const errorMessage = `GPU_EXECUTION_ERROR: ${e.message}`;
                console.error(`[Browser] An error occurred during GPU execution:`, e);
                ws.send(JSON.stringify({ result: errorMessage }));
            }
        };

        async function runGpuTest({ wgslCode, kernelEntryPoint, input }) {
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) throw new Error("Failed to get GPU adapter.");

            const device = await adapter.requestDevice();
            const shaderModule = device.createShaderModule({ code: wgslCode });

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }
                ]
            });

            const pipeline = await device.createComputePipelineAsync({
                layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                compute: { module: shaderModule, entryPoint: kernelEntryPoint }
            });

            const inputData = Array.isArray(input) ? input : [input];
            
            const inputBufferSize = Math.max(16, inputData.length * 4);
            const outputBufferSize = 16;

            const inputBuffer = device.createBuffer({
                size: inputBufferSize,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                mappedAtCreation: true
            });
            new Float32Array(inputBuffer.getMappedRange()).set(inputData);
            inputBuffer.unmap();

            const outputBuffer = device.createBuffer({
                size: outputBufferSize,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
            });

            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: inputBuffer } },
                    { binding: 1, resource: { buffer: outputBuffer } }
                ]
            });

            const commandEncoder = device.createCommandEncoder();
            const pass = commandEncoder.beginComputePass();
            pass.setPipeline(pipeline);
            pass.setBindGroup(0, bindGroup);
            pass.dispatchWorkgroups(1);
            pass.end();

            const gpuReadBuffer = device.createBuffer({
                size: outputBufferSize,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
            });
            commandEncoder.copyBufferToBuffer(outputBuffer, 0, gpuReadBuffer, 0, outputBufferSize);
            device.queue.submit([commandEncoder.finish()]);

            await gpuReadBuffer.mapAsync(GPUMapMode.READ);
            const resultArray = new Float32Array(gpuReadBuffer.getMappedRange().slice(0));
            gpuReadBuffer.unmap();
            
            inputBuffer.destroy();
            outputBuffer.destroy();
            gpuReadBuffer.destroy();

            return resultArray;
        }
    </script>
</body>
</html>