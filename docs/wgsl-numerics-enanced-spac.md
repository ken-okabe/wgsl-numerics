
# **WGSL-Numerics Enhanced Testing Framework v2.0**

## **1. 設計思想：本質への集中**

このテストフレームワークは、\*\*「開発者はWGSLの純粋な計算ロジックのみに集中できる」\*\*という理想状態を達成するために設計されています。その思想は、以下の原則に支えられています。

  * **TDDサイクルの完全自動化**: 開発者は`_red`（意図的に失敗する実装）と`_green`（正しい実装）のカーネルを用意するだけで、テストの妥当性（Red）と実装の正当性（Green）が自動的に検証されます。これにより、常に健全な状態で開発を進行できます。

  * **宣言的テストスイート**: 開発者は`main.test.ts`に「`qp_mul`をテスト対象とする」という趣旨の宣言を一行追加するだけで、新たなテストスイートを開始できます。テストケースを手動で記述する手間は一切ありません。

  * **ポリシーベースの網羅的テスト生成**: `wgsl-numerics-test-policy.md`の思想に基づき、Tier 1（厳密）、Tier 2（実用）、Tier 3（特殊・境界値）のテストケースが自動生成されます。これにより、手動では見落としがちなエッジケースを確実にカバーします。

  * **高度な関心事の分離**: 実行基盤（Chrome/WebSocket）、テストロジック（TDDサイクル）、データ生成、結果分析といった各要素がモジュールとして完全に分離されています。これにより、フレームワーク自体の高い保守性と拡張性を維持します。

  * **深層的な品質の探究**: このフレームワークの真価は、単なるロジックの正しさだけでなく、**プラットフォーム固有の挙動（GPUのゼロの符号の正規化など）といった、検出が極めて困難な問題を表面化させる能力**にあります。これは、我々が構築するライブラリが、表層的ではない真の信頼性を獲得するために不可欠なプロセスです。

-----

## **2. 詳細仕様：フレームワーク構成要素**

あなたが直接関わるのは主に`kernels.wgsl`と`main.test.ts`の2ファイルですが、フレームワーク全体は以下の役割で構成されています。

| ファイル | 役割 | 詳細 |
| :--- | :--- | :--- |
| `code/kernels.wgsl` | **【あなたの主な実装場所】** | テスト対象となるWGSLカーネル（`_red`, `_green`）を実装します。 |
| `tests/main.test.ts` | **【テストの起点】** | 新しい関数のテストスイートを宣言し、テスト全体を実行するエントリーポイントです。 |
| `tests/test-case-generator.ts` | テストデータ自動生成 | ポリシーに基づき、単項・二項演算子用のTier 1〜3のテストデータを生成します。 |
| `tests/assert.ts` | 結果の検証（アサート） | GPUから返された`QuadFloat`を、適応的な許容誤差（Epsilon）を用いて期待値と比較します。 |
| `tests/diagnostics.ts` | 詳細な診断レポート生成 | テスト失敗時に、どの値がどう異なっていたかを詳細に出力し、デバッグを支援します。 |
| `tests/quality-assurance.ts`| 品質トレンド分析 | テスト全体の成功率や実行時間を記録・分析し、品質の低下（リグレッション）を警告します。 |
| `code/_test-runner.html` | WGSL実行環境 | Bunから起動されたChrome内で、**特殊値を正確に復元しつつ**WGSLコードを実行するサンドボックスです。 |

-----

## **3. WGSL実装ガイドライン（完全版）**

後続の開発者が無駄なエラーに時間を費やすことなく、円滑に実装を進めるための完全なガイドラインです。

### **3.1. TDDの契約：RedとGreenの実装**

  * **`_red`カーネル**: **いかなる入力に対しても必ず失敗する**ように実装してください。

      * **悪い例**: `return input;` （入力と期待値が同じ`NaN`などの場合にTDD違反となるため）
      * **良い例**: `return vec4<f32>(999.0);` （期待値と一致する可能性が極めて低い、固定の不正値を返す）

  * **`_green`カーネル**: 正しい計算結果を返す、製品版の実装です。

### **3.2. バッファインターフェース規約**

すべてのカーネルは、以下の汎用的なインターフェースを厳守してください。

  * **入力**: `@group(0) @binding(0) var<storage, read> generic_input: array<f32>;`

      * **単項演算** (`qp_negate`など): `QuadFloat`値が`generic_input[0..3]`に格納されます。
      * **二項演算** (`qp_add`など): 1つ目の`QuadFloat`が`generic_input[0..3]`に、2つ目が`generic_input[4..7]`に格納されます。

  * **出力**: `@group(0) @binding(1) var<storage, read_write> generic_output: vec4<f32>;`

      * 計算結果の`QuadFloat`（`vec4<f32>`）をこの変数に代入してください。

### **3.3. 解決済みの課題とWGSL実装パターン**

これまでのデバッグで得られた知見です。これらのパターンに従うことで、既知の問題を完全に回避できます。

1.  **【解決済み】 `unresolved value` コンパイルエラー**

      * **原因**: `struct`でバッファをラップしたことによる、WGSLパーサーの曖昧な解釈。
      * **対策**: バッファ変数は`struct`でラップせず、必ずグローバルスコープで直接型定義してください。
      * **OK**: `var<storage, read_write> generic_output: vec4<f32>;`
      * **NG**: `struct Out { val: vec4<f32> }; var<storage, read_write> generic_output: Out;`

2.  **【解決済み】 特殊値（`NaN`, `Infinity`, `-0`）の入力**

      * **現状**: テストフレームワークがデータ転送を完全にハンドリングするため、**WGSLカーネルは`NaN`, `Infinity`, `+/-0`を直接入力として受け取れます。**
      * **対策**: `isNan()`や`isInf()`といったWGSLの組込み関数を使い、特殊な入力値を適切に処理するロジックを`_green`カーネルに実装してください。

3.  **【仕様】 ゼロの符号（`+/-0`）の挙動**

      * **現象**: GPUはハードウェア/ドライバレベルの最適化により、`-0`を`+0`として扱うことがあります。
      * **対策（プロジェクト方針）**: この挙動を「バグ」ではなく「プラットフォームの仕様」と捉えます。ライブラリの動作一貫性を保つため、**テスト側の期待値をGPUの挙動に合わせます。**
          * 例えば、`test-case-generator.ts`では、`negate(0)` や `negate(-0)` の期待値が、GPUの出力に合わせて `+0` となるように調整されています。新たな関数で同様の現象が起きた場合も、この方針に従ってください。

4.  **【TIPS】 WGSLコンパイラの厳格なルール**

      * モジュールスコープの定数は`const`で宣言してください。
      * 変数は一行に一つずつ宣言してください (`var a, b: f32;` は不可)。
      * `Infinity`をリテラルで生成する場合は、`let zero = 0.0; let inf = 1.0 / zero;` のように、コンパイル時評価を回避してください。

### **3.4. 実装テンプレート：`qp_abs`の実装例**

これから`qp_abs`を実装する場合の、理想的な`kernels.wgsl`への追記例です。

```wgsl
// kernels.wgsl に以下を追記

// --- qp_abs ---
@compute @workgroup_size(1)
fn qp_abs_main_red(@builtin(global_invocation_id) global_id: vec3<u32>) {
    if (global_id.x > 0u) { return; }
    // 確実に失敗させるため、固定の不正値を返す
    generic_output = vec4<f32>(-999.0, -999.0, -999.0, -999.0);
}

@compute @workgroup_size(1)
fn qp_abs_main_green(@builtin(global_invocation_id) global_id: vec3<u32>) {
    if (global_id.x > 0u) { return; }

    let a = vec4<f32>(generic_input[0], generic_input[1], generic_input[2], generic_input[3]);

    // isInfやisNanなどの特殊値ハンドリングもここで行う
    // (この例では単純化のため省略)
    
    // 最初の要素が負の場合、すべての要素の符号を反転させる
    if (a.x < 0.0) {
        generic_output = -a;
    } else {
        generic_output = a;
    }
}
```