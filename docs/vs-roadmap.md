承知いたしました。仕様書の完全準拠に向けた段階的な実装ロードマップについて、議論を開始しましょう。

前回の分析で明らかになった**「テスト基盤は堅牢だが、ライブラリ本体とそれを支えるアーキテクチャの根幹が未実装である」**という現状を踏まえ、仕様書の思想を忠実に実現するためのロードマップ案を以下に提示します。

これは議論のたたき台です。ぜひご意見をお聞かせください。

---

### **WGSL-Numerics 3.0 実装ロードマップ (提案)**

仕様書が定める「信頼性の階層モデル」そのものを実装の道標とし、土台から段階的に信頼性を積み上げていくアプローチを提案します。

#### **フェーズ 0: 基盤の確立とアーキテクチャの修正 (最優先)**

**目標:** ライブラリ開発をスケールさせるための根幹的な仕組みを実装し、既存コードを仕様に準拠させる。

1. **依存関係解決エンジンの実装**:
    * **タスク**: テストランナー(`test-runner.test.ts`)を修正し、各モジュールの`index.ts`に記述されるであろう`dependencies`配列を読み取り、実行時にWGSLコードを自動的に結合する機能を実装します。
    * **理由**: これは仕様書が定める「原則2：依存関係の明示的宣言」を実現する最重要機能です。これがなければ、関数間の再利用性が失われ、ライブラリはスケールしません。

2. **ディレクトリ構造の修正**:
    * **タスク**: `code/src/LV2_Primitives/qp_negate`を、仕様書通り`code/src/LV3_BasicArithmetic/qp_negate`に移動します。
    * **理由**: 「原則3：依存関係による階層の自動決定」の思想を、開発の初期段階から厳格に適用します。

3. **`dependencies` 宣言の追加**:
    * **タスク**: 既存の`qp_negate/index.ts`と`qp_debug_is_nan/index.ts`に、空の`dependencies = []`を追記します。
    * **理由**: すべてのモジュールがこの規約に従うという一貫性を保ちます。

---

#### **フェーズ 1: LV2 プリミティブの実装**

**目標:** すべての算術演算の精度を保証する、誤差なし変換（EFT）を完全に実装・検証する。

1. **`two_sum`の実装**:
    * **タスク**: `LV2_Primitives/two_sum`モジュールを作成し、`kernel.wgsl`と`index.ts`（神託関数、テストケース含む）を実装します。
2. **`quick_two_sum`の実装**:
    * **タスク**: 同様に`quick_two_sum`を実装します。
3. **`two_prod`の実装**:
    * **タスク**: FMA（融合積和演算）を利用する`two_prod`を実装します。

---

#### **フェーズ 2: LV3 基本演算APIの実装**

**目標:** LV2プリミティブを実際に**依存関係として利用**し、四則演算を構築する。

1. **`qp_add`の実装**:
    * **タスク**: `LV3_BasicArithmetic/qp_add`モジュールを作成します。`index.ts`では`dependencies = ["LV2_Primitives/two_sum", "LV2_Primitives/quick_two_sum"]`のように、**フェーズ0で実装した依存関係解決エンジンが初めて意味を持つ実装**を行います。
    * **理由**: ここでアーキテクチャの根幹が正しく機能することを実証します。
2. **`qp_sub`, `qp_mul`, `qp_div` の実装**:
    * **タスク**: 同様に、`two_sum`や`two_prod`への依存を宣言しながら、残りの四則演算を実装します。

---

#### **フェーズ 3: LV4 拡張数学・比較APIの実装**

**目標:** 複雑なアルゴリズムを実装し、仕様書が予見する「未知のプリミティブの発見プロセス」を実践する。

1. **比較演算APIの実装 (`qp_eq`, `qp_gt`など)**:
    * **タスク**: LV3の`qp_sub`などを利用して実装します。
2. **`qp_sqrt` (平方根) の実装**:
    * **タスク**: ニュートン法などの反復計算を実装します。この過程で、もし収束判定に「許容誤差を考慮した比較」のような共通処理が必要になった場合、それを例えば`LV3`の**新たな独立モジュールとして切り出し、先に実装・検証**します。
    * **理由**: これこそが、仕様書が定義する「新規プリミティブの公理化プロセス」です。ライブラリが有機的に成長する過程をここで実践します。
3. **その他のLV4関数の実装**:
    * **タスク**: `qp_sin`, `qp_log`など、依存関係を意識しながら他の関数を実装します。

---

#### **フェーズ 4: LV5+ 応用APIの実装と最終化**

**目標:** ライブラリの最終的な価値となる高レベルAPIを実装し、NPMパッケージとして提供する準備を整える。

1. **データ構造の実装**:
    * **タスク**: `QVector`, `QMatrix`などを扱うTypeScript側のクラスや型定義を実装します。
2. **線形代数API (`qla_`) の実装**:
    * **タスク**: `qla_vec_dot`などを、これまでの`qp_`関数を組み合わせて実装します。
3. **TypeScriptラッパー層の開発**:
    * **タスク**: 仕様書の「8.2. 内部アーキテクチャ」で言及されている、WebGPUの複雑な処理をカプセル化するラッパーを開発し、利用者がWGSLを意識せずにライブラリを使えるようにします。
4. **NPMパッケージ化**:
    * **タスク**: プロジェクトをビルドし、NPMパッケージとして公開できる状態にまとめます。

---

いかがでしょうか。特に**フェーズ0の依存関係解決エンジンの実装**が、このプロジェクト全体の成否を分ける鍵だと考えています。まずはこの点について、ご意見をいただけますでしょうか。
