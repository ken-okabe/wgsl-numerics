# **WGSL-Numerics 3.0 仕様書：科学技術のための数値演算環境〜自己検証型・階層化アーキテクチャ**

**バージョン:** 1.0
**日付:** 2025-08-05
**ステータス:** **制定**

### **はじめに**

#### **1. 目的と哲学：信頼性、持続可能性、そして人間中心設計**

##### **1.1. 目的**

本ライブラリ「WGSL-Numerics」の唯一の目的は、WebGPU上で、科学技術計算、物理シミュレーション、金融モデリング、その他あらゆる高精度な演算を要求するアプリケーションで利用可能な、**完全に信頼できる汎用128bit（四倍精度）数値演算環境**を構築することである。

##### **1.2. 開発哲学**

本ライブラリは、その根幹に以下の三つの哲学を置く。

1.  **信頼性 (Reliability):** 全ての関数は、厳格な**テスト駆動開発**によってその正しさが保証される。テストが存在しないコードは、存在しないのと同じである。
2.  **持続可能性 (Sustainability):** コードは書かれる時間より、読まれ、修正され、拡張される時間の方が圧倒的に長い。我々は、未来の開発者（1年後の自分自身を含む）のために、**可読性**と**保守性**を最高レベルに保つ。
3.  **人間中心設計 (Human-Centered Design):** ライブラリは、開発者が複雑な数値演算の実装詳細を意識することなく、本来の目的に集中できる、直感的で安全なツールでなければならない。

##### **1.3. バージョン3.0の定義**

本仕様書が定義するバージョン3.0は、単なるAPIの集合体ではない。それは、アーキテクチャそのものが品質を保証する、**自己検証型のシステム**としての再定義である。ライブラリの正しさは、個々の関数の正しさの総和によってのみならず、関数間の依存関係が織りなす論理構造の完全性によって担保される。

-----

### **第I部：アーキテクチャと信頼性保証**

#### **2. 設計思想：依存関係に基づく階層化アーキテクチャ**

##### **2.1. 統一設計思想**

本アーキテクチャの根底には、ただ一つの、しかし極めて強力な思想が存在する。

> **すべての関数は、テスト可能な独立したモジュールであり、その関係性は依存関係によってのみ定義される。**

この思想は、ライブラリのあらゆる側面に浸透し、その構造と開発プロセスを規定する。

##### **2.2. アーキテクチャの三大原則**

1.  **原則1：ヘルパー関数の完全な排除**
    ライブラリに「ヘルパー」という曖昧な概念は存在しない。`two_sum`のような関数であっても、それは`qp_add`の補助ではなく、**誤差なし変換という明確な責務を持つ独立したプリミティブ**である。すべてのコード片は、固有のテストスイートを持つ公式な関数モジュールとして扱われなければならない。

2.  **原則2：依存関係の明示的宣言**
    ある関数`A`が別の関数`B`を内部で利用する場合、`A`は`B`に**依存する**。この依存関係は、関数`A`の`index.ts`ファイル内に、`dependencies`配列として明示的に宣言されなければならない。

    ```typescript
    // 例: code/src/LV3_BasicArithmetic/qp_add/index.ts
    export const dependencies = [
        "LV2_EFT/two_sum",
        "LV2_EFT/quick_two_sum"
    ];
    ```

    テストフレームワークは、この宣言を読み取り、実行時に必要なWGSLコードを\*\*自動的に結合（concatenate）\*\*する責務を負う。これにより、WGSLに`import`機能がないという制約を克服し、コードの再利用性と保守性を最大化する。

3.  **原則3：依存関係による階層の自動決定**
    ライブラリの`LV`（レベル）階層は、ファッションではなく、依存関係の論理構造によって**必然的に決定される**。被依存関数は、常に依存する関数よりも下位のレベルに配置されなければならない。これにより、「信頼性の階層モデル」 がコードのディレクトリ構造そのものに反映される。

##### **2.3. 未知のプリミティブの発見プロセス**

本仕様書は、現時点で特定されている関数群がすべてであるとは**規定しない**。むしろ、\*\*「未知のプリミティブを発見することは、開発プロセスの一部である」\*\*と定義する。

###### **2.3.1. 分析：なぜ新たな関数が必要になるのか**

四則演算 (`qp_add`, `qp_sub`, `qp_mul`, `qp_div`) の範囲においては、我々が特定した3つの誤差なし変換（EFT）関数 (`two_sum`, `quick_two_sum`, `two_prod`) でほぼ十分である。これらは`LV2`に配置される、代数学の最も基本的な部品群と言える。

しかし、仕様書は`qp_sqrt`（平方根）や`qp_log`（自然対数）、`qp_sin`（正弦）といった、単純な代数ではない\*\*「解析学」**の領域に属する関数を要求している。これらの関数は、多くが**反復法**や**級数展開\*\*といったアルゴリズムによって実装される。

**思考実験：`qp_sin` (テイラー展開) の実装**

`sin(x)`のテイラー展開は以下の式で表される。
$$\sin(x) = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} + \dots$$
この計算を`QuadFloat`で実行するには、以下の処理がループ内で何度も繰り返される。

1.  `x`のべき乗 (`x^3`, `x^5`, ...) を計算する (`qp_mul`)
2.  階乗 (`3!`, `5!`, ...) を計算する (`qp_mul`)
3.  べき乗を階乗で割る (`qp_div`)
4.  符号を反転させながら足し合わせる (`qp_add`, `qp_sub`)
5.  **収束判定:** 前のステップの結果との差が、許容誤差`epsilon`より小さくなったか？

このステップ5 \*\*「収束判定」\*\*こそが、新たな被依存関数の需要源である。単純な`a == b`では浮動小数点数の比較はできない。我々が必要とするのは、**許容誤差を考慮した比較**、つまり`abs(a - b) < epsilon`という演算である。この演算は、`qp_sin`だけでなく、反復法を用いるあらゆる関数で共通して必要となる、新たなプリミティブなのである。

###### **2.3.2. 新規プリミティブの公理化プロセス**

`LV4`の`qp_sin`を実装する過程で、もし新たな共通処理（例：`qp_abs`や`qp_eq_eps`）が必要だと判明した場合、開発者は以下のプロセスを**必ず**踏まなければならない。

1.  その共通処理を、適切なレベル（例：`LV3`）の**新しい独立した関数モジュール**として定義する。
2.  その新関数のためのテストケースと神託（Oracle）を実装する。
3.  TDDサイクルを通じてその新関数の信頼性を完全に保証する。
4.  その後初めて、`qp_sin`の`dependencies`にその新関数を追加し、`qp_sin`の実装を開始する。

このプロセスにより、ライブラリは常にその内部構造の論理的整合性と信頼性を保ちながら、有機的に成長することができる。

#### **3. テストフレームワーク「Numeris-Test」：品質保証の心臓部**

##### **3.1. 思想：「ツール → 基礎 → 応用」という段階的アプローチ**

本フレームワークは、家を建てる前にまず精密な測定器と設計図を完璧に準備するという思想に基づいている。すなわち、WGSLで書かれた数値計算コードという「建造物」の正しさを保証するための「測定器」＝テストフレームワーク自体を、何よりも先に、最も厳格な基準で構築する。この「ツール → 基礎 → 応用」という段階的アプローチこそが、ライブラリ全体の信頼性を揺るぎないものにするための唯一の道である。

##### **3.2. 検証の公理 (LV0) と神託（Oracle）アーキテクチャ**

テストの信頼性は、その判定基準の信頼性に依存する。本フレームワークは、判定基準そのものをGPUという被検証システムから完全に分離し、「聖域化」することで、その信頼性を確立している。

###### **3.2.1. 聖域化された検証者**

`assertQpEqual`関数 は、このライブラリにおける「等価性」を定義する、唯一の判定基準（公理）である。その実装は、WGSLやGPU環境から完全に独立したCPU側の世界で、桁落ちの原理的な発生しないJavaScriptの`BigInt`を用いることで、絶対的な信頼性を担保している。この「ものさし」自体の正しさは、自己検証テストによって証明されており、これこそが我々の品質保証の基点となる。

###### **3.2.2. 適応的許容誤差の自動計算**

`BigInt`による厳格な比較を基礎としつつ、本フレームワークは`code-bak`バージョンから再統合された、より実践的な検証能力を持つ。高レベルな検証関数`assertQpEqualTiered`は、内部で`calculateTolerance`を呼び出す。これは、テストの階層（Tier）と演算の種類（`OperationType`）を考慮し、テストポリシー に基づいて最適な許容誤差 (`epsilon`) を動的に算出する。これにより、単純な加算では`1e-30`という極めて厳格な基準を、`sin`のような超越関数ではより現実的な基準を、というように、テストの文脈に応じた最適な検証が自動的に行われる。

###### **3.2.3. 神託の分離**

「あるべき正しい答え」を計算する神託（Oracle）は、各関数モジュールの`index.ts`が`default export`として自己完結して提供する。この神託関数は、`QuadFloat`というWGSLの実装詳細には一切関与せず、純粋な数学的実体として`Decimal.js`ライブラリを用いて値を計算する。テストフレームワークは、この数学的に純粋な`Decimal`値を受け取り、後述するGPUシミュレーションを適用して最終的な期待値を生成する。この責務の完全な分離が、アーキテクチャ全体の明瞭性と保守性を保証している。

##### **3.3. テストの自動構築と実行**

###### **3.3.1. テスト対象の自動発見**

開発者が新しい関数モジュール（例：`src/LV3/qp_mul/`）をディレクトリ構造に追加するだけで、テストランナー (`test-runner.test.ts`) はそれを自動的に認識する。実行時に`src`ディレクトリを走査し、`index.ts`と`kernel.wgsl`のペアを発見すると、Bun Testの`describe`ブロックを動的に生成し、テストスイートを自動的に構築する。これにより、テスト実行のための宣言的な作業が最小限に抑えられる。

###### **3.3.2. TDDサイクルの厳格な自動検証**

本フレームワークは、テスト駆動開発（TDD）の「Red→Green」サイクルを契約として強制する。各テストケースの実行時、テストランナーはまず`main_red`カーネル（意図的に失敗するよう実装されたカーネル）を呼び出し、それが`expect(...).toThrow()`アサーションによって**期待通りに失敗すること**を検証する。このRedステージの検証をパスした場合にのみ、`main_green`カーネル（製品版の実装）が実行され、その正しさが検証される。このプロセスにより、テストそのものの信頼性と、実装の正当性が二重に保証される。

##### **3.4. 高忠実度GPUシミュレーション**

###### **3.4.1. `simulateGpuBehavior`**

神託が計算した理想的な数学的値と、実際のGPUが返す値との間には、`f32`という媒体に起因する避けられない差異（丸め誤差、`+/-0`の正規化など）が存在する。`generateExpected`関数内の`simulateGpuBehavior`は、この差異をCPU側で精密に模倣する。`fround`関数（`Float32Array`を利用）による丸めの適用や、ゼロの符号の統一といった処理を経て生成された期待値は、GPUが実際に取りうる物理的挙動を忠実に反映したものとなる。これにより、テストは物理的に不可能な理想値を追うのではなく、現実のGPU環境下での正しさを検証することができる。

##### **3.5. テストケースの自動生成**

###### **3.5.1. テストポリシーの階層**

すべてのテストケースは、その目的の明確化のため、以下の3階層（Tier）のいずれかに属する。

  * **Tier 1 (厳密精度):** `f32`で正確に表現可能な値（整数、2のべき乗の分数など）を用い、理論的に完璧な結果との比較を行う。
  * **Tier 2 (実用精度):** `π`や`0.1`など、`f32`では不正確となるが実用上頻出する値を用い、現実的な使用場面での精度を検証する。
  * **Tier 3 (ストレス):** `NaN`, `Infinity`, `f32`の最大・最小値などの極値・特殊値を用い、極限条件での堅牢性を検証する。

###### **3.5.2. ポリシーに準拠した体系的な値選択ロジック**

`test-case-generator.ts`は、`code-bak`から再統合された、テストポリシーに厳密に従う値選択ロジックを保有する。`TIER1_VALUES`, `TIER2_VALUES`, `TIER3_VALUES`といった定数群は、テストの設計意図（なぜその値が選ばれたのか）をコード上で明確に表現している。さらに、Tier 2のテストでは、入力値を`fround`関数に通すことで、より現実的な入力データをシミュレートする工夫がなされている。これにより、手動では見落としがちなエッジケースを網羅的かつ体系的にカバーする。

##### **3.6. 継続的な品質監視とレポート**

###### **3.6.1. 品質トレンドの分析**

テストは一度成功すれば終わりではない。`quality-assurance.ts`の`generateQualityReport`関数は、テスト実行の履歴を分析し、前回実行結果と比較して品質トレンドを「↗️ Improving」「↘️ Declining」「→ Stable」といった形で可視化する。これにより、意図しないリグレッション（品質低下）を早期に発見し、ライブラリの品質を継続的に高いレベルで維持することが可能となる。

###### **3.6.2. 失敗時の詳細診断と推奨アクション**

テストが予期せず失敗した場合、`diagnostics.ts`の`generateFailureDiagnostics`関数が起動する。この関数は、単に成否を報告するだけでなく、期待値と実測値の成分ごとの詳細な誤差分析や、ゼロの符号の不一致といった特定の問題に対する専用のエラーメッセージを出力する。さらに、「推奨アクション」（`Recommended Actions`）を提示することで、開発者が迅速に問題の原因を特定し、修正にあたることを強力に支援する。

-----

### **第II部：API仕様とデータ構造**

#### **4. 信頼性の階層モデル (v2.0) と関数カタログ**

本ライブラリのAPI群は、その依存関係に基づき、厳格な階層モデル（LV）に従って構成される。下位の階層の信頼性が、その上位の階層の信頼性を再帰的に保証する。この構造は、ライブラリのディレクトリ構造そのものに反映される。

##### **4.1. 階層の定義と責務**

  * **LV0: 検証の公理 (Axiom of Verification)**
      * **責務:** 検証の絶対基準。CPU側で実行。
  * **LV1: デバッグ API (Debug API)**
      * **責務:** 内部状態を判定する最も基本的なGPU関数。
  * **LV2: 誤差なし変換プリミティブ (EFT Primitives)**
      * **責務:** すべての算術演算の精度を保証する数学的基礎部品。
  * **LV3: 基本演算 API (Basic Arithmetic API)**
      * **責務:** LV2を利用して四則演算と基本変換、単純な数学関数を実現する。
  * **LV4: 拡張数学・比較 API (Extended Math & Comparison API)**
      * **責務:** LV3までを組み合わせて、複雑な数学関数や比較演算を実装する。
  * **LV5+: 応用 API (Applied APIs)**
      * **責務:** LV4までを利用して高レベル機能を提供する。

-----

##### **4.2. LV1: デバッグと堅牢性API (`qp_debug_`)**

  * **依存関係:** LV0

| 関数名 | シグネチャ | 説明 |
| :--- | :--- | :--- |
| `qp_debug_is_nan` | `(a: QuadFloat) -> bool` | `a`が非数(`NaN`)であるかを判定する。 |
| `qp_debug_is_inf` | `(a: QuadFloat) -> bool` | `a`が無限大(`inf`)であるかを判定する。 |
| `qp_debug_is_finite`| `(a: QuadFloat) -> bool` | `a`が有限の値であるか（`NaN`でも`inf`でもないか）を判定する。 |

-----

##### **4.3. LV2: 誤差なし変換プリミティブ (EFT Primitives)**

  * **依存関係:** LV0

| 関数名 | シグネチャ | 説明 |
| :--- | :--- | :--- |
| `two_sum` | `(a: f32, b: f32) -> vec2<f32>` | `a + b` を計算し、和と丸め誤差を返す、EFTの根幹。 |
| `quick_two_sum`| `(a: f32, b: f32) -> vec2<f32>` | `\|a\| >= \|b\|`が保証される場合の高速な`two_sum`。 |
| `two_prod` | `(a: f32, b: f32) -> vec2<f32>` | `a * b` を計算し、積と丸め誤差を返す。`fma`組込み関数を利用する。 |

-----

##### **4.4. LV3: 基本演算 API (`qp_`)**

  * **依存関係:** LV0, LV1, LV2

| 関数名 | シグネチャ | 説明 |
| :--- | :--- | :--- |
| `qp_from_f32` | `(v: f32) -> QuadFloat` | 単精度数から四倍精度数への変換。 |
| `qp_negate` | `(a: QuadFloat) -> QuadFloat` | 符号を反転する (`-a`)。 |
| `qp_add` | `(a: QuadFloat, b: QuadFloat) -> QuadFloat` | 加算 `a + b` を実行する。 |
| `qp_sub` | `(a: QuadFloat, b: QuadFloat) -> QuadFloat` | 減算 `a - b` を実行する。 |
| `qp_mul` | `(a: QuadFloat, b: QuadFloat) -> QuadFloat` | 乗算 `a * b` を実行する。 |
| `qp_div` | `(a: QuadFloat, b: QuadFloat) -> QuadFloat` | 除算 `a / b` を実行する。 |
| `qp_fma` | `(a: QuadFloat, b: QuadFloat, c: QuadFloat) -> QuadFloat` | 融合積和演算 `a*b + c` を実行。 |
| `qp_abs` | `(a: QuadFloat) -> QuadFloat` | 絶対値を計算する。 |
| `qp_sign` | `(a: QuadFloat) -> QuadFloat` | 符号を計算する (-1, 0, 1)。 |

-----

##### **4.5. LV4: 拡張数学・比較 API (`qp_`)**

  * **依存関係:** LV0 - LV3

| 関数名 | シグネチャ | 説明 |
| :--- | :--- | :--- |
| `qp_floor` | `(a: QuadFloat) -> QuadFloat` | 床関数を計算する。 |
| `qp_ceil` | `(a: QuadFloat) -> QuadFloat` | 天井関数を計算する。 |
| `qp_round` | `(a: QuadFloat) -> QuadFloat` | 最近接整数への丸め。 |
| `qp_sqrt` | `(a: QuadFloat) -> QuadFloat` | 平方根を計算する。（ニュートン法） |
| `qp_pow` | `(base: QuadFloat, exp: QuadFloat) -> QuadFloat` | べき乗 `base^exp` を計算する。 |
| `qp_log` | `(a: QuadFloat) -> QuadFloat` | 自然対数を計算する。 |
| `qp_exp` | `(a: QuadFloat) -> QuadFloat` | 指数関数 e\<sup\>a\</sup\> を計算する。 |
| `qp_sin` | `(a: QuadFloat) -> QuadFloat` | 正弦関数を計算する。 |
| `qp_cos` | `(a: QuadFloat) -> QuadFloat` | 余弦関数を計算する。 |
| `qp_atan2` | `(y: QuadFloat, x: QuadFloat) -> QuadFloat` | 2引数逆正接。 |
| `qp_eq` | `(a: QuadFloat, b: QuadFloat) -> bool` | 比較 `a == b` を実行する。 |
| `qp_neq` | `(a: QuadFloat, b: QuadFloat) -> bool` | 比較 `a != b` を実行する。 |
| `qp_gt` | `(a: QuadFloat, b: QuadFloat) -> bool` | 比較 `a > b` を実行する。 |
| `qp_lt` | `(a: QuadFloat, b: QuadFloat) -> bool` | 比較 `a < b` を実行する。 |
| `qp_gte` | `(a: QuadFloat, b: QuadFloat) -> bool` | 比較 `a >= b` を実行する。 |
| `qp_lte` | `(a: QuadFloat, b: QuadFloat) -> bool` | 比較 `a <= b` を実行する。 |

-----

##### **4.6. LV5+: 応用 API**

  * **依存関係:** LV0 - LV4

###### **4.6.1. 線形代数API (`qla_`)**

| 関数名 | シグネチャ | 説明 |
| :--- | :--- | :--- |
| `qla_vec_add` | `(a: QVector, b: QVector) -> QVector` | ベクトル加算 `a + b`。 |
| `qla_vec_sub` | `(a: QVector, b: QVector) -> QVector` | ベクトル減算 `a - b`。 |
| `qla_vec_scale` | `(vec: QVector, scalar: QuadFloat) -> QVector` | ベクトルのスカラー倍。 |
| `qla_vec_dot` | `(a: QVector, b: QVector) -> QuadFloat` | ベクトルの内積。 |
| `qla_vec_norm` | `(a: QVector) -> QuadFloat` | ベクトルのL2ノルム（長さ）を計算する。 |
| `qla_vec_normalize`| `(a: QVector) -> QVector` | ベクトルを正規化（単位ベクトル化）する。 |
| `qla_mat_vec_mul` | `(mat: QMatrix, vec: QVector) -> QVector` | 行列とベクトルの積。 |
| `qla_mat_mat_mul` | `(a: QMatrix, b: QMatrix) -> QMatrix` | 行列同士の積。 |
| `qla_mat_transpose` | `(mat: QMatrix) -> QMatrix` | 行列を転置する。 |
| `qla_mat_to_vec` | `(mat: QMatrix) -> QVector` | 行列を1次元ベクトルに平坦化する。 |
| `qla_debug_vec_has_nan` | `(vec: QVector) -> bool` | ベクトルのいずれかの要素に`NaN`が含まれるかを判定する。 |
| `qla_debug_vec_has_inf` | `(vec: QVector) -> bool` | ベクトルのいずれかの要素に`inf`が含まれるかを判定する。 |

###### **4.6.2. テンソル演算API (`qta_`)**

| 関数名 | シグネチャ | 説明 |
| :--- | :--- | :--- |
| `qta_tensor_reshape` | `(a: QTensor, new_shape: array<u32>) -> QTensor` | テンソルの形状を変更する。要素の総数は不変。 |
| `qta_tensor_permute` | `(a: QTensor, axes: array<u32>) -> QTensor` | テンソルの軸を、指定された順序で入れ替える。 |
| `qta_tensor_contract` | `(a: QTensor, b: QTensor, axes: array<vec2<u32>>) -> QTensor` | 2つのテンソルを、指定された軸に沿って縮約する。 |

###### **4.6.3. 数値アルゴリズムAPI (`qna_`)**

| 関数名 | シグネチャ | 説明 |
| :--- | :--- | :--- |
| `qna_eigen_jacobi` | `(mat: QMatrix) -> EigenResult` | ヤコビ法により対称行列の固有値と固有ベクトルを計算する。 |
| `qna_svd` | `(mat: QMatrix) -> SVDResult` | 行列の特異値分解を行う。 |
| `qna_interpolate_linear` | `(table: array<vec2<QuadFloat>>, x: QuadFloat) -> QuadFloat` | 2次元の点データから、指定された`x`に対応する値を線形補間する。 |

###### **4.6.4. 可視化・解析支援API (`qva_`)**

| 関数名 | シグネチャ | 説明 |
| :--- | :--- | :--- |
| `qva_mat_downsample` | `(mat: QMatrix, factor: u32) -> QMatrix` | 行列を指定された係数でダウンサンプリングし、全体像を把握しやすくする。 |
| `qva_tensor_slice` | `(tensor: QTensor, axis: u32, index: u32) -> QTensor` | 高階テンソルの特定の軸を固定し、低階のテンソル（スライス）を抽出する。 |
| `qva_vec_to_histogram`| `(vec: QVector, bins: u32) -> array<u32>` | ベクトルの値の分布を計算し、ヒストグラムを生成する。 |

-----

#### **5. 型システムとデータ構造**

| 構造体名 | WGSL定義（概念） | 説明 |
| :--- | :--- | :--- |
| `QuadFloat` | `struct QuadFloat { val: vec4<f32> };` | 4つの`f32`で一つの128-bit数を表現する。 |
| `QVector` | `struct QVector { data: array<QuadFloat>, size: u32 };` | サイズ情報を持つベクトル。 |
| `QMatrix` | `struct QMatrix { data: array<QuadFloat>, rows: u32, cols: u32 };` | 行・列情報を持つ行列。 |
| `QTensor` | `struct QTensor { data: array<QuadFloat>, shape: array<u32>, strides: array<u32> };` | 形状とストライド情報を持つ汎用テンソル。 |
| `SVDResult` | `struct SVDResult { U: QMatrix, S: QVector, Vh: QMatrix };` | 特異値分解の結果を格納する。 |
| `EigenResult`| `struct EigenResult { eigenvalues: QVector, eigenvectors: QMatrix };` | 固有値分解の結果を格納する。 |
| `QMetadata`| `struct QMetadata { version: u32, timestamp: u32, ... };` | データが生成された文脈を記録し、計算の再現性を保証する。CPU側で管理される。 |

-----

### **第III部：実装と運用**

#### **6. WGSL実装ガイドライン**

###### **6.1. TDD契約：Red/Greenカーネルの実装**

  * **`main_red`カーネル**: **いかなる入力に対しても必ず失敗する**ように実装しなければならない。期待値と一致する可能性が極めて低い、固定の不正値（例：`vec4<f32>(-999.0)`）を返すことを推奨する。
  * **`main_green`カーネル**: 正しい計算結果を返す、製品版の実装である。

###### **6.2. バッファインターフェース規約**

すべてのカーネルは、以下の汎用的なインターフェースを厳守しなければならない。

  * **入力**: `@group(0) @binding(0) var<storage, read> generic_input: array<f32>;`
  * **出力**: `@group(0) @binding(1) var<storage, read_write> generic_output: vec4<f32>;`

###### **6.3. 解決済みの課題と実装パターン**

過去のデバッグで得られた知見であり、すべての開発者はこれらのパターンに従うことで、既知の問題を完全に回避しなければならない。

1.  **`struct`ラップの禁止:** バッファ変数は`struct`でラップせず、必ずグローバルスコープで直接型定義すること。
2.  **特殊値の扱い:** テストフレームワークがデータ転送を完全にハンドリングするため、WGSLカーネルは`NaN`, `Infinity`, `+/-0`を直接入力として受け取れる。`isNan()`のようなWGSL組込み関数を適切に利用すること。
3.  **文法:** 変数は一行に一つずつ宣言する (`var a, b: f32;` は不可)。

#### **7. クックブック (Cookbook: Usage Examples)**

*新規参画者がライブラリの利用方法を迅速に習得できるよう、具体的な使用例を提供する。「生きたドキュメント」として機能する。*

  * **01: ベクトルの内積**
    ```wgsl
    // WGSLカーネル内
    // var v1, v2: QVector; (CPUからデータ設定済みと仮定)
    var dot_product: QuadFloat = qla_vec_dot(v1, v2);
    ```
  * **02: 3x3行列の固有値計算**
    ```wgsl
    // WGSLカーネル内
    // var matrix: QMatrix; (CPUからデータ設定済みと仮定)
    var result: EigenResult = qna_eigen_jacobi(matrix);
    // result.eigenvalues はサイズ3のQVector
    ```

#### **8. ライブラリの提供形態とアーキテクチャ**

##### **8.1. 最終形態：NPMパッケージとしてのTypeScriptラッパー**

本ライブラリは、最終的にNPMパッケージとして配布される、高レベルな**JavaScript/TypeScriptライブラリ**として提供される。利用者は、WGSLやWebGPUの低レベルな詳細を意識することなく、本ライブラリを利用できる。

##### **8.2. 内部アーキテクチャ：エンジン層とラッパー層**

ライブラリは、内部的にWGSLを完全にラッピングするラッパー・パターンを採用する。

  * **エンジン層 (WGSL):** 本仕様書で定義される全ての`qp_`, `qla_`等の関数。GPU上で実際の高精度計算を実行する。
  * **ラッパー層 (JS/TS):** 開発者が直接利用するAPI。WebGPUの初期化、バッファ管理、データ変換、非同期処理の管理など、全ての複雑な処理をカプセル化する。