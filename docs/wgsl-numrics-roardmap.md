
### **WGSL Numerics 実装戦略：テスト駆動開発（TDD）ロードマップ**

本ロードマップは、仕様書で定義された「完全に信頼できる」四倍精度数値計算ライブラリを、テスト駆動開発（TDD）のアプローチを用いて構築するための、段階的かつ具体的な実行計画を定めるものです。

#### **フェーズ 0: 環境構築**

-   **目的:** 開発とテストに必要な基本的な環境を整備する。
    
-   **タスク:**
    
    1.  **プロジェクトセットアップ:** TypeScript, WGSLシェーダーローダー、ビルドツール（Vite, Webpackなど）を含む基本的なWebGPU開発環境を構築する。
        
    2.  **バージョン管理:** Gitリポジトリを初期化し、開発ブランチ戦略（例: Git Flow）を決定する。
        

#### **フェーズ 1: 基盤構築 — テストフレームワーク「Numeris-Test」の実装**

-   **目的:** WGSLで書かれたコードの正しさをCPU側（TypeScript/JavaScript）から検証し、性能を計測するための「測定器」を先に作る。
    
-   **なぜ最初に行うか:** このフレームワークがなければ、TDDの「Red（失敗するテストを書く）」サイクルを開始することすらできません。これは、家を建てる前に測量道具と設計図を準備するのと同じです。
    
-   **主要コンポーネントと実装ステップ:**
    
　実装済み
            
    3.  **高精度比較関数:**
        
        -   CPU側で、2つの`QuadFloat`（`vec4<f32>`の配列として表現）が許容誤差（epsilon）の範囲内で等しいかを判定するヘルパー関数 `assertQpEqual(a, b, epsilon)` を実装する。
            
    4.  **マイクロベンチマーク機能:**
        
        -   WebGPUの`timestamp-query`機能を利用し、各テストカーネルのGPU上での純粋な実行時間をナノ秒単位で計測する機能を`TestRunner`に統合する。
            

#### **フェーズ 2: コア機能開発 — `qp_` (Quad-precision Primitives) のTDDサイクル**

**目的:** 構築したテストフレームワークを使い、ライブラリの最も基本的な構成要素である`qp_`関数の信頼性を一つずつ確保する。

**実践的TDDフロー (`qp_add`を例に) と運用指針:**

1. **Red→Greenサイクルの明示的管理**
    - 失敗するテスト（Red）→最小実装（Green）→リファクタの流れを、Bunテストのコメントや`test.skip`/`test.only`などで明示的に管理し、TDDの進行を分かりやすくする。
        - 例: Red段階では`test.skip('Red: qp_from_f32 fails as expected', ...)`で明示、Green段階で`test('Green: qp_from_f32 minimal pass', ...)`に変更、Refactor段階で`test.only`や詳細コメントで進行状況を明示。
        - テストファイルの先頭や各テストケースに「Red/Green/Refactor」コメントを残し、どの段階か一目で分かるようにする。
        - TDDサイクルの進行はコミットメッセージやPRタイトルにも反映し、履歴管理も厳密に行う。

2. **WGSLカーネルの分割管理**
    - `wgsl/`ディレクトリ内で、各`qp_`関数ごとに個別のWGSLファイル（例: `qp_add.wgsl`）を用意し、テストごとに必要なカーネルだけを読み込む構成にすることで、可読性・保守性を向上させる。

3. **テストデータの自動生成**
    - テストデータ（特に境界値やランダム値）はTypeScript側で自動生成スクリプトを用意し、テストケースの網羅性を高める。

4. **ベンチマーク値の閾値管理**
    - ベンチマーク（実行時間）は環境依存で大きく変動するため、「絶対値でのアサート」ではなく、「前回比での劣化検知」や「参考値としての出力」に留める。

5. **テスト失敗時のデバッグ情報出力**
    - テスト失敗時に「入力値・期待値・実際の出力値」を詳細に出力する仕組みを入れておき、デバッグ効率を高める。

---

**TDDフロー例（`qp_add`）:**
1.  **Red (失敗するテストの記述):**
    -   `qp_add`のテストケースをTypeScriptで記述する。例えば、「`1.0 + 2.0`が`3.0`になること」を検証するテストを作成する。
    -   このテストは、内部で`qp_add`を呼び出すWGSLコードを生成し、Bunテストで実行する。この時点では`qp_add`は未実装かスタブ（空の関数）なので、テストは**必ず失敗する**。
2.  **Green (テストをパスする最小限のコードを記述):**
    -   テストが成功するためだけの、最もシンプルな`qp_add`のロジックをWGSLで実装する。
    -   再度テストを実行し、**成功することを確認する**。
3.  **Refactor (リファクタリング):**
    -   テストが通る状態を維持したまま、WGSLコードの可読性を高めたり、パフォーマンスを改善したりする。

**実装順序の推奨:** 依存関係の少ない単純なものから順に実装する。
    -   `qp_from_f32` → `qp_negate` → `qp_add` / `qp_sub` → `qp_mul` → `qp_div` → `qp_sqrt` ...
        

#### **フェーズ 3: 階層の拡張 — `qla_`, `qta_`, `qna_` への展開**

-   **目的:** TDDのプラクティスを、ベクトル、行列、テンソルといった、より高次のAPI群に適用する。
    
-   **戦略:**
    
    -   **境界値テスト:**  `qla_vec_dot`のような関数では、典型的な値だけでなく、ゼロベクトル、非常に大きい/小さい値を持つベクトル、直交するベクトルなど、エッジケースを網羅したテストケースを作成する。
        
    -   **コード生成の活用:** 仕様書の方針通り、テストデータの生成にスクリプトを活用する。例えば、特定の性質（対称行列、対角行列など）を持つ`QMatrix`のテストデータを、PythonやTypeScriptスクリプトで自動生成し、テストの網羅性を高める。
        

### **結論**

この「**ツール → 基礎 → 応用**」という段階的なロードマップは、仕様書で掲げた壮大な目標を、着実に、そして現実的に達成するための青写真です。この規律あるプロセスに従うことで、`WGSL Numerics`は名実ともに「完全に信頼できる」ライブラリとなり、WebGPUにおける科学技術計算の未来を切り拓く基盤となるでしょう。

 ---

 