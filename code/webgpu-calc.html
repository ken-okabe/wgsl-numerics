<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>WebGPU Minimal Calc Test</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 2em;
        }

        #result {
            font-weight: bold;
            color: #007700;
        }
    </style>
</head>

<body>
    <h1>WebGPU Minimal Calc Test</h1>
    <button id="run">GPUで 2 + 3 を計算</button>
    <div id="result">結果: (未実行)</div>
    <script type="module">
        async function runCalc() {
            if (!navigator.gpu) {
                document.getElementById('result').textContent = 'WebGPU未対応';
                return;
            }
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            // WGSL: 2+3を計算してoutput[0]に格納
            const shaderCode = `
        @group(0) @binding(0) var<storage, read_write> output: array<f32>;
        @compute @workgroup_size(1)
        fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
          output[0] = 2.0 + 3.0;
        }
      `;
            const module = device.createShaderModule({ code: shaderCode });
            const outputBuffer = device.createBuffer({
                size: 4,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
            });
            const bindGroupLayout = device.createBindGroupLayout({
                entries: [{ binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }]
            });
            const pipeline = device.createComputePipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                compute: { module, entryPoint: 'main' }
            });
            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [{ binding: 0, resource: { buffer: outputBuffer } }]
            });
            const commandEncoder = device.createCommandEncoder();
            const pass = commandEncoder.beginComputePass();
            pass.setPipeline(pipeline);
            pass.setBindGroup(0, bindGroup);
            pass.dispatchWorkgroups(1);
            pass.end();
            const gpuReadBuffer = device.createBuffer({
                size: 4,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
            });
            commandEncoder.copyBufferToBuffer(outputBuffer, 0, gpuReadBuffer, 0, 4);
            device.queue.submit([commandEncoder.finish()]);
            await gpuReadBuffer.mapAsync(GPUMapMode.READ);
            const arrayBuf = gpuReadBuffer.getMappedRange();
            const result = new Float32Array(arrayBuf)[0];
            document.getElementById('result').textContent = '結果: ' + result;
            gpuReadBuffer.unmap();
            // Bunサーバーにfetchで結果を送信
            let status = (result === 5) ? 'success' : 'failure';
            fetch(`/report?status=${status}`);
        }
        document.getElementById('run').onclick = runCalc;
        window.onload = runCalc;
    </script>
</body>

</html>